# QEMU，一个快速和可移植的动态翻译

> Fabrice Bellard

## 文摘

我们介绍了QEMU的内部结构，这是一个使用原始可移植动态转换器的快速机器仿真器。它在多个主机(x86、PowerPC、ARM和Sparc)上仿真多个cpu (x86、PowerPC、ARM、Sparc、Alpha和MIPS)。QEMU支持完整的系统仿真，即在虚拟机中运行完整且未修改的操作系统，在Linux用户模式仿真中，为一个目标CPU编译的Linux进程可以在另一个CPU上运行。

## 1介绍

QEMU是一个机器仿真器:它可以在虚拟机中运行未经修改的目标操作系统(如Windows或Linux)及其所有应用程序。QEMU本身运行在多个主机操作系统上，如Linux、Windows和Mac OS x。主机和目标cpu可以不同。

QEMU的主要用途是在另一个操作系统上运行一个操作系统，比如Linux上的Windows或Windows上的Linux。另一种用法是调试，因为可以轻松地停止虚拟机，并且可以检查、保存和恢复虚拟机的状态。此外，可以通过添加新的机器描述和新的模拟设备来模拟特定的嵌入式设备。

QEMU还集成了一个Linux特定的用户模式模拟器。它是机器仿真器的一个子集，在另一个CPU上为一个目标CPU运行Linux进程。它主要用于测试跨编译器的结果或测试CPU模拟器，而不必启动一个完整的虚拟机。

QEMU由几个子系统组成:

* CPU仿真器(目前为x861, PowerPC, ARM和Sparc)
* 模拟设备(如VGA显示器、16450串口、PS/2鼠标键盘、IDE硬盘、NE2000网卡，…)
* 用于将模拟设备连接到相应主机设备的通用设备(例如块设备、字符设备、网络设备)
* 实例化仿真设备的机器描述(如PC、PowerMac、Sun4m)
* 调试器
* 用户界面

本文研究QEMU使用的动态转换器的实现。动态转换器执行目标CPU指令到主机指令集的运行时转换。产生的二进制代码存储在转换缓存中，以便可以重用。与解释器相比，它的优点是只获取和解码目标指令一次。

通常，动态翻译器很难从一个主机移植到另一个主机，因为整个代码生成器必须重写。它表示的工作量与向C编译器添加新目标的工作量大致相同。QEMU要简单得多，因为它只是将GNU C编译器[5]离线生成的机器码片段连接起来。

CPU模拟器还面临其他更经典但更困难的[2]问题:

* 翻译代码缓存的管理
* 寄存器分配
* 条件代码优化
* 直接块链接
* 内存管理
* 自修改代码支持
* 例外支持
* 硬件中断
* 用户模式模拟

## 2可移植的动态翻译

### 2.1描述

第一步是将每个目标CPU指令分割成更少的称为微操作的更简单的指令。每个微操作都是由一小段C代码实现的。这个小C源代码由GCC编译成一个目标文件。选择微操作是为了使它们的数目比所有指令和操作数的组合小得多(通常是几百个) 目标CPU的。从目标CPU指令到微操作的转换完全是用手工编码完成的。源代码经过了可读性和紧凑性的优化，因为这一阶段的速度没有解释器那么重要。

一个名为dyngen的编译时工具使用包含微操作的目标文件作为输入来生成动态代码生成器。这个动态代码生成器在运行时被调用，以生成一个连接多个微操作的完整主机函数。

这个过程类似于[1]，但是为了获得更好的性能，需要在编译时做更多的工作。特别是，一个关键的思想是，在QEMU常数参数可以给微观操作。为此，使用GCC为每个常量参数生成伪代码重新定位。这使dyngen工具能够定位重定位并生成适当的C代码，以便在构建动态代码时解决它们。还支持重定位，以支持对静态数据和微操作中的其他函数的引用。

### 2.2的例子

考虑这样一种情况，我们必须将以下PowerPC指令转换为x86代码:

```
addi r1,r1，-16 # r1 = r1 -16
```

以下微操作是由PowerPC代码转换器生成的:

```
movl_T0_r1 # T0 = r1
addl_T0_im -16 # T0 = T0 - 16
movl_r1_T0 # r1 = T0
```

在不影响生成代码质量的情况下，最小化了微操作的数量。

例如，我们不是在每32个PowerPC寄存器之间生成所有可能的移动，而是生成到几个临时寄存器的移动和从临时寄存器的移动。这些寄存器T0、T1、T2通常通过使用GCC静态寄存器变量扩展存储在主机寄存器中。

微操作movl T0 r1一般编码为:

```c
void op_movl_T0_r1(void)
{
  T0 = env->regs[1];
}
```

env是一个包含目标CPU状态的结构。

32个PowerPC寄存器存储在数组中

```
env->regs[32].
```

addl T0 im 更有趣，因为它使用了一个常量参数，其值是在运行时确定的:

```c
extern int __op_param1;
void op_addl_T0_im(void)
{
  T0 = T0 + ((long)(&__op_param1));
}
```

dyngen生成的代码生成器采用opc ptr指向的微操作流并输出主机代码在位置gen代码ptr。微操作参数由opparam ptr指定:

```c
[...]
for(;;) {
  switch(*opc_ptr++) {
    [...]
    case INDEX_op_movl_T0_r1:
    {
      extern void op_movl_T0_r1();
      memcpy(gen_code_ptr, (char *)&op_movl_T0_r1+0, 3);
      gen_code_ptr += 3;
      break;
    }
    case INDEX_op_addl_T0_im:
    {
      long param1;
      extern void op_addl_T0_im();
      memcpy(gen_code_ptr,
      (char *)&op_addl_T0_im+0, 6);
      param1 = *opparam_ptr++;
      *(uint32_t *)(gen_code_ptr + 2) = param1;
      gen_code_ptr += 6;
      break;
    }
    [...]
    }
  }
  [...]
}
```

对于大多数微操作，例如movl T0 r1，只复制GCC生成的主机代码。当使用常数参数时，dyngen使用的事实是 GCC生成对op param1的重定位，用运行时参数(这里称为param1)修补生成的代码。

当代码生成器运行时，输出以下主机代码:

```
# movl_T0_r1
# ebx = env->regs[1]
mov 0x4(%ebp),%ebx
# addl_T0_im -16
# ebx = ebx - 16
add $0xfffffff0,%ebx
# movl_r1_T0
# env->regs[1] = ebx
mov %ebx,0x4(%ebp)
```

在x86上，T0映射到ebx寄存器，而CPU状态上下文映射到ebp寄存器。

## 2.3 Dyngen实现

dyngen工具是QEMU转换过程的关键。在包含微操作的对象文件上运行时执行以下任务:

* 对目标文件进行解析，获取其符号表、重定位项和代码段。此传递取决于主机对象文件格式(dyngen支持ELF (Linux)、PE-COFF (Windows)和MACH-O (Mac OS X))。
* 微操作位于代码部分使用符号表。执行特定于主机的方法来获取复制代码的开始和结束。通常，函数序言和尾声被跳过。
* 对每个微操作的重新定位进行检查，以获得常数参数的数量。常量参数重定位是通过使用特定的符号名称op paramN来检测的。
* 生成一个C语言的内存拷贝来拷贝微操作代码。每个微操作的代码的重新定位用于对复制的代码进行修补，以便对其进行适当的重新定位。重新定位补丁是特定于主机的。
* 对于一些主机，如ARM，常量必须存储在生成的代码附近，因为它们是通过PC的相对负载以较小的位移访问的。在生成的代码中执行主机特定的步骤来重新定位这些常量。

在编译微操作代码时，使用一组GCC标志将函数序言和尾声代码的生成操作为易于解析的形式。一个虚拟装配宏迫使GCC总是终止对应于每个微处理器的函数

使用单个返回指令进行操作。如果在单个微操作中生成多个返回指令，则代码连接将不起作用。

## 3实现细节

### 3.1翻译块和翻译缓存

当QEMU第一次遇到一段目标代码时，它会将其转换为主机代码，直到下一次跳转或修改静态CPU状态的指令，而这在转换时是无法推导出来的。我们称之为基本块

#### 翻译块(TBs)。

一个16 MB 的缓存保存最近使用的TBs。

为简单起见，它在满的时候被完全刷新。

静态CPU状态被定义为输入TB时在转换时被认为是已知的CPU状态的一部分。例如，程序计数器(PC)在所有目标上的翻译时都是已知的。在x86上，静态CPU状态包含更多的数据，以便能够生成更好的代码。例如，了解CPU是处于受保护模式还是实际模式、用户模式还是内核模式、或者默认的操作数大小是16位还是32位是很重要的。

### 3.2寄存器分配

QEMU使用固定的寄存器分配。这意味着每个目标CPU寄存器都映射到一个固定的主机寄存器或内存地址。在大多数主机上，我们简单地将所有目标寄存器映射到内存，只在主机寄存器中存储一些临时变量。的分配临时变量硬编码在每个目标CPU描述中。这种方法的优点是简单和可移植性。

QEMU的未来版本将使用动态临时寄存器分配器来消除目标寄存器直接存储在主机寄存器中的一些不必要的移动。

### 3.3 条件代码优化

良好的CPU条件代码仿真(x86上的eflags寄存器)是获得良好性能的关键。

QEMU使用惰性条件代码计算:它只存储一个操作数(称为CC SRC)、结果(称为CC DST)和操作类型(称为CC OP)，而不是在每个 x86 指令之后计算条件代码。对于一个32位的加法，比如 R = A + B，我们有:

```
CC_SRC=A
CC_DST=R
CC_OP=CC_OP_ADDL
```

知道我们从CC OP中存储的常量中添加了32位，我们可以从CC SRC和CC DST中恢复a、B和R。然后，如果下一个指令需要，那么所有相应的条件代码，如零结果(ZF)、非正结果(SF)、进位(CF)或溢出(OF)都可以被恢复。

通过使用一次生成一个完整TB的代码这一事实，在翻译时进一步优化条件代码评估。对生成的代码执行向后传递，以查看以下代码是否使用了CC OP、CC SRC或CC DST。结束时

对于TB，我们考虑使用这些变量。然后删除值在以下代码中不使用的赋值。

### 3.4直接块链接

在执行每个TB之后，QEMU使用模拟程序计数器(PC)和静态CPU状态的其他信息，使用散列表查找下一个TB。如果下一个TB还没有被翻译，则启动一个新的翻译。否则，将跳转到下一个TB。

为了加速新模拟PC已知的最常见情况(例如在条件跳转之后)，QEMU可以修补一个TB，使其直接跳转到下一个。

最可移植的代码使用间接跳转。在某些主机上(如x86或PowerPC)，直接修补分支指令，这样块链接就没有开销。

#### 3.5内存管理

对于系统仿真，QEMU使用mmap()系统调用来仿真目标MMU。只要模拟的OS不使用主机OS.2保留的区域，它就可以工作

为了能够启动任何操作系统，QEMU还支持一个软件MMU。在这种模式下，MMU虚拟地址到物理地址的转换是在每次访问内存时完成的。QEMU使用地址转换缓存来加速转换。

为了避免在每次MMU映射更改时刷新已翻译的代码，QEMU使用物理索引的翻译缓存。这意味着每个TB都用它的物理地址进行索引。

当MMU映射改变时，TBs的链接被重置(即一个TB不能再直接跳转到另一个TB)，因为跳转目标的物理地址可能会改变。

### 3.6自修改代码和翻译

#### 代码无效

在大多数cpu上，自修改代码很容易处理，因为会执行特定的代码缓存失效指令来表示代码已经修改。它足以使相应的翻译代码无效。

但是在x86这样的cpu上，当代码被修改时，应用程序不会发出指令缓存失效的信号，因此自修改代码是一个特殊的挑战

当为TB生成翻译后的代码时，如果相应的主机页不是只读的，那么它将被写保护。如果对页面进行了写访问，那么QEMU将使其中的所有翻译代码无效，并重新启用对其的写访问。通过维护给定页面中包含的每个已翻译块的链接列表，可以有效地完成正确的翻译代码失效。还维护了其他链表来撤消直接块链接。

当使用软件MMU时，代码失效会更有效:如果给定的代码页由于写访问而频繁失效，那么就会构建一个位图来表示页面内的所有代码。进入该页面的每个存储都将检查位图，以确定代码是否真的需要作废。它避免了仅在某些情况下才使代码无效在页面中修改数据。

### 3.7异常支持

longjmp()用于在遇到除0之类的异常时跳转到异常处理代码。当不使用软件MMU时，使用主机信号处理程序来捕获无效的内存访问。

QEMU支持精确异常，因为它总是能够在异常发生时检索精确的目标CPU状态。没有什么需要做的大部分的目标CPU状态，因为它是显式存储和修改的翻译代码。没有显式存储的目标CPU状态(例如当前程序计数器)是通过重新翻译TB来检索的，在这种模式中，异常发生在每条被翻译的目标指令之前的S被记录。的引发异常的主机程序计数器用于查找相应的目标指令和状态S。

硬件中断

为了更快，如果一个硬件中断正在等待，QEMU不会检查每个TB。相反，用户必须异步调用一个特定的函数来通知中断正在等待。此函数重置当前执行的TB的链接。它确保在CPU模拟器的主循环中执行将很快返回。然后主循环测试一个中断是否挂起并处理它。

#### 3.9用户模式模拟

QEMU支持用户模式模拟，以便在另一个CPU上运行为一个目标CPU编译的Linux进程。

在CPU级别，用户模式模拟只是整个系统模拟的一个子集。没有进行MMU模拟，因为QEMU假设用户内存映射由主机OS处理。QEMU包含一个通用的Linux系统调用转换器，用于处理endianness问题和32/64位转换。因为QEMU支持异常，所以它可以精确地模拟目标信号。每个目标线程在一个主机thread5中运行。

## 4移植工作

为了将QEMU移植到新的主机CPU，必须执行以下操作:

* dyngen必须被移植(见2.2节)。
* 微操作使用的临时变量可以映射到主机的特定寄存器中以优化性能。
* 大多数主机cpu需要特定的指令来保持指令之间的一致性缓存和内存。
* 如果直接块链接是用修补的分支指令，一些特定的汇编宏必须提供。

估计了QEMU的整体移植复杂性与动态链接器相同。

## 5 的性能

为了度量仿真带来的开销，我们比较了BYTEmark基准测试在x86主机上本机模式下的性能，以及在x86目标用户模式仿真下的性能。

用户模式QEMU(版本0.4.2)的速度比integer代码上的本机代码慢4倍左右。

对于浮点代码，它要慢10倍。这可以理解为在静态CPU状态下缺少x86 FPU堆栈指针的结果。在全系统仿真中，软件MMU的成本降低了2倍。

在整个系统仿真中，QEMU的速度大约是Bochs[4]的30倍。

用户模式QEMU比valgrind快1.2倍——skin=none版本1.9.6[6]，一个手动编码的从x86到x86的动态转换器，通常用于调试程序。——skin=none选项确保Valgrind不会生成调试代码。

## 结论和未来的工作

QEMU已经达到了可以在日常工作中使用的程度，特别是对于Windows等商业x86操作系统的仿真。PowerPC目标已经接近为了启动Mac OS X, Sparc开始启动Linux。迄今为止，还没有其他动态转换器能够在如此多的主机上支持如此多的目标，这主要是因为移植的复杂性被低估了。QEMU方法似乎是性能和复杂性之间的一个很好的折衷。

今后仍需解决以下问题:

* 移植:QEMU在PowerPC和x86主机上得到了很好的支持。Sparc、Alpha、ARM和MIPS上的其他端口需要打磨。QEMU还在很大程度上依赖于用于编译微操作定义的准确GCC版本。
* 完整的系统仿真:需要添加ARM和MIPS目标。
* 性能:可以提高软件MMU的性能。一些关键的微操作也可以在汇编语言中手工编码，而不需要在当前的翻译框架中做太多的修改。CPU主循环也可以用汇编语言手工编码。
* 虚拟化:当主机和目标相同时，可以按原样运行大部分代码。最简单的实现是照常模拟目标内核代码，但按原样运行目标用户代码。
* 调试:可以像在SIMICS中那样添加缓存模拟和循环计数器来进行调试 [3]。

## 7可用性

QEMU可以在 http://bellard.org/qemu上找到

## 引用

* [1] Ian Piumarta, Fabio Riccardi, Optimizing direct threaded code by selective inlining, Proceedings of the 1998 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI).
* [2] Mark Probst, Fast Machine-Adaptable Dynamic binary Translation, Workshop on Binary Translation 2001.
* [3] Peter S. Magnusson et al., SimICS/sun4m: A Virtual Workstation, Usenix Annual Technical Conference, June 15-18, 1998.
* [4] Kevin Lawton et al., the Bochs IA-32 Emulator Project, http://bochs.sourceforge.net.
* [5] The Free Software Foundation, the GNU Compiler Collection, http://gcc.gnu.org.
* [6] Julian Seward et al., Valgrind, an open-source memory debugger for x86-GNU/Linux, http://valgrind.kde.org/.
* [7] The BYTEmark benchmark program, BYTE Magazine, Linux version available at http://www.tux.org/˜mayer/linux/bmark.html.

## 笔记

* 1 x86 cpu是指与Intel 80386处理器兼容的处理器。

* 2 这种模式现在已经被弃用了，因为它需要一个打了补丁的目标OS，而且目标OS可以访问主机QEMU地址空间。

* 3 为简单起见，QEMU实际上会为所有支持的cpu实现这种忽略代码缓存失效指令的行为。

* 4 在x86情况下，虚拟CPU无法获取确切的eflags寄存器，因为在某些情况下，由于条件代码优化，它不会被计算。这不是一个主要问题，因为在任何情况下，模拟代码仍然可以在同一点重新启动。

* 5 在撰写本文时，QEMU对线程的支持被认为是不成熟的，因为它的CPU核心模拟中存在锁定问题。
